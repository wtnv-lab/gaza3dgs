const ZapparCamera=pc.createScript("zapparCamera");ZapparCamera.attributes.add("Front Facing Camera",{type:"boolean",default:!1,description:"Should front camera be used"}),ZapparCamera.attributes.add("Mirror Mode",{type:"string",enum:[{None:"none"},{CSS:"css"},{Poses:"poses"}],default:"none",description:"How the scene and camera is mirrored/flipped"}),ZapparCamera.attributes.add("Camera Pose",{type:"string",enum:[{Default:"default"},{Anchor:"anchor"},{Attitude:"attitude"}],default:"default",description:"Pose mode of the tracked content"}),ZapparCamera.prototype.initialize=function(){if(this.canvas=this.app.graphicsDevice.canvas,this.gl=this.canvas.getContext("webgl2")||this.canvas.getContext("webgl"),!this.gl)throw new Error("no gl");this.cameraPoseMatrix=new pc.Mat4,this.mirror=!1,ZapparCamera.prototype.pipeline=new Zappar.Pipeline,this.pipeline.glContextSet(this.gl);const getActiveSource=()=>this["Front Facing Camera"]?ZapparCamera.prototype.source.user:ZapparCamera.prototype.source.rear;this.app.on("zappar:camera",(e=>{const{message:a,userFacing:t}=e;"flip"===a&&(void 0===t?(this["Front Facing Camera"]=!this["Front Facing Camera"],getActiveSource().start()):(this["Front Facing Camera"]=t,getActiveSource().start()))})),ZapparCamera.prototype.source={user:new Zappar.CameraSource(this.pipeline,Zappar.cameraDefaultDeviceID(!0)),rear:new Zappar.CameraSource(this.pipeline,Zappar.cameraDefaultDeviceID(!1))},Zappar.permissionRequestUI().then((e=>{this.app.fire("zappar:camera",{message:"permission_granted",granted:e}),e?getActiveSource().start():Zappar.permissionDeniedUI()})),document.addEventListener("visibilitychange",(()=>{const e=getActiveSource();if("hidden"===document.visibilityState)e.pause();else e.start()})),this.initializeBackground()},ZapparCamera.prototype.update=function(){if(!this.pipeline||!this.app.autoRender)return;this.pipeline.frameUpdate();const e=Array.from(this.pipeline.cameraPoseDefault());this.cameraPoseMatrix.set(e);const{width:a,height:t}=this.canvas;switch(this["Mirror Mode"]){case"none":this.mirror=!1,this.canvas.style.transform="";break;case"poses":this.mirror=!0,this.canvas.style.transform="";break;case"css":this.mirror=!1,this.canvas.style.transform="scaleX(-1)";break;default:throw new Error("Unknown mirror type")}this.pipeline.processGL(),this.pipeline.frameUpdate();const r=this.pipeline.cameraModel(),i=Array.from(Zappar.projectionMatrixFromCameraModel(r,a,t)),n=(new pc.Mat4).set(i),s=this.entity.camera;s&&(s.calculateProjection=e=>{e.copy(n);const a=n.data;s.horizontalFov=!1,s.fov=2*Math.atan(1/a[5])*180/Math.PI,s.aspectRatio=a[5]/a[0],s.farClip=a[14]/(a[10]+1),s.nearClip=a[14]/(a[10]-1)},this.updateBackgroundTexture(this.pipeline))},ZapparCamera.prototype.initializeBackground=function(){this.backgroundPlane=new pc.Entity,this.backgroundPlane.addComponent("render",{type:"plane"}),this.backgroundPlane.setLocalEulerAngles(-90,0,0),this.entity.addChild(this.backgroundPlane),this.texture=new pc.Texture(this.app.graphicsDevice,{format:pc.PIXELFORMAT_R8_G8_B8}),this.material=new pc.Material,this.material.cull=pc.CULLFACE_FRONT,this.backgroundPlane.render.material=this.material;const e={attributes:{position:pc.SEMANTIC_POSITION,texcoord:pc.SEMANTIC_TEXCOORD0},vshader:"\n            precision highp float;\n            attribute vec3 position;\n            attribute vec2 texcoord;\n            uniform mat4 texTransform;\n\n            uniform mat4 matrix_model;\n            uniform mat4 matrix_viewProjection;\n\n            varying vec2 uv;\n\n            void main(void)\n            {\n                uv = (texTransform * vec4(texcoord.xy, 0., 1.)).xy;\n\n                gl_Position = matrix_viewProjection * matrix_model * vec4(position, 1.0);\n            }",fshader:"\n            precision highp float;\n            varying vec2 uv;\n            uniform sampler2D uCameraTexture;\n\n            void main(void)\n            {\n                vec4 color = texture2D(uCameraTexture, uv);\n                gl_FragColor = color;\n            }"},a=new pc.Shader(this.app.graphicsDevice,e);this.material.shader=a,this.material.setParameter("uCameraTexture",this.texture)},ZapparCamera.prototype.updateBackgroundTexture=function(e){const{aspectRatio:a,fov:t,farClip:r}=this.entity.camera;this.backgroundPlane.setPosition(0,0,-(r-Number.MIN_VALUE));const i=this.backgroundPlane.getPosition().length(),n=t*Math.PI/180,s=i*Math.tan(n/2)*2,o=s*a;this.backgroundPlane.setLocalScale(o,1,s),this.texture.impl&&this.texture.impl._glTexture?this.texture.impl._glTexture=e.cameraFrameTextureGL():this.texture._glTexture=e.cameraFrameTextureGL();const p=e.cameraFrameTextureMatrix(this.app.graphicsDevice.width,this.app.graphicsDevice.height,this.mirror);this.material.setParameter("texTransform",p)};const zapparImageTracker=pc.createScript("zapparImageTracker");zapparImageTracker.attributes.add("Target Image",{type:"asset",assetType:"binary",description:"Image Target file (.zpt) "}),zapparImageTracker.attributes.add("Target Upright",{type:"boolean",default:!0,description:"Offset rotations for upright targets"}),zapparImageTracker.attributes.add("Zappar Camera",{type:"entity",description:"Zappar Camera (Drag from hierarchy)"}),zapparImageTracker.prototype.initialize=function(){if(!this["Zappar Camera"])throw new Error("Zappar Camera attribute undefined - Please link camera entity to attribute.");if(this.Camera=this["Zappar Camera"].script.zapparCamera,this.pipeline=this.Camera.pipeline,this.imageTracker=new Zappar.ImageTracker(this.pipeline),this.imageTracker.onNewAnchor.bind((e=>{console.log("New anchor has appeared:",e.id)})),this.imageTracker.onVisible.bind((e=>{console.log("Anchor is visible:",e.id)})),this.imageTracker.onNotVisible.bind((e=>{console.log("Anchor is not visible:",e.id)})),!this["Target Image"])throw new Error("No target image found in entity assets");const e=this["Target Image"].resource;this.imageTracker.loadTarget(e)},zapparImageTracker.prototype.update=function(){const e=this["Target Upright"]?90:0;this.imageTracker.visible.forEach((a=>{const{cameraPoseMatrix:r}=this.Camera,t=Array.from(a.pose(r.data,this.Camera.mirror)),i=(new pc.Mat4).set(t);this.entity.setEulerAngles(i.getEulerAngles().x+e,i.getEulerAngles().y,i.getEulerAngles().z),this.entity.setPosition(i.getTranslation())}))};const ZapparFaceTracker=pc.createScript("zapparFaceTracker");ZapparFaceTracker.attributes.add("Max Faces",{type:"number",default:1,description:"The maximum number of faces the tracker will look for"}),ZapparFaceTracker.attributes.add("Target Upright",{type:"boolean",default:!0,description:"Offset rotations for upright targets"}),ZapparFaceTracker.attributes.add("Zappar Camera",{type:"entity",description:"Zappar Camera (Drag from hierarchy)"}),ZapparFaceTracker.prototype.initialize=function(){if(!this["Zappar Camera"])throw new Error("Zappar Camera attribute undefined - Please link camera entity to attribute.");this.Camera=this["Zappar Camera"].script.zapparCamera,this.faceTracker=new Zappar.FaceTracker(this.Camera.pipeline),this.faceTracker.loadDefaultModel().then((()=>{console.log("face tracking model loaded")})),this.faceTracker.onNewAnchor.bind((a=>{console.log("New anchor has appeared:",a.id)})),this.faceTracker.onVisible.bind((a=>{console.log("Anchor is visible:",a.id)})),this.faceTracker.onNotVisible.bind((a=>{console.log("Anchor is not visible:",a.id)})),this.faceTracker.maxFaces=this["Max Faces"]},ZapparFaceTracker.prototype.update=function(){const{cameraPoseMatrix:a}=this.Camera,e=this["Target Upright"]?90:0;this.faceTracker.visible.forEach((r=>{const t=Array.from(r.pose(a.data,this.Camera.mirror)),i=(new pc.Mat4).set(t);this.entity.setEulerAngles(i.getEulerAngles().x+e,i.getEulerAngles().y,i.getEulerAngles().z),this.entity.setPosition(i.getTranslation())}))};const zapparInstantTracker=pc.createScript("zapparInstantTracker");zapparInstantTracker.attributes.add("Placement Button",{type:"entity",description:"Button which locks tracking state"}),zapparInstantTracker.attributes.add("Anchor Camera Offset",{type:"number",default:[0,0,-5],array:!0,description:"Offset the target by this vector while its camera anchored"}),zapparInstantTracker.attributes.add("Zappar Camera",{type:"entity",description:"Zappar Camera (Drag from hierarchy)"}),zapparInstantTracker.prototype.initialize=function(){if(!this["Zappar Camera"])throw new Error("Zappar Camera attribute undefined - Please link camera entity to attribute.");this.Camera=this["Zappar Camera"].script.zapparCamera,this.pipeline=this.Camera.pipeline;this.app.on("game:rocket_placed",(()=>{this.hasPlaced=!0})),this.instantTracker=new Zappar.InstantWorldTracker(this.pipeline)},zapparInstantTracker.prototype.update=function(){const a=this["Anchor Camera Offset"];this.hasPlaced||this.instantTracker.setAnchorPoseFromCameraOffset(...a);const{cameraPoseMatrix:t}=this.Camera,{anchor:e}=this.instantTracker,r=Array.from(e.pose(t.data,this.Camera.mirror)),n=(new pc.Mat4).set(r);this.entity.setEulerAngles(n.getEulerAngles().x,n.getEulerAngles().y,n.getEulerAngles().z),this.entity.setPosition(n.getTranslation())};const ZapparFaceLandmark=pc.createScript("zapparFaceLandmark");ZapparFaceLandmark.attributes.add("Landmark Target",{type:"string",enum:[{"Eye (Left)":"EYE_LEFT"},{"Eye (Right)":"EYE_RIGHT"},{"Ear (Left)":"EAR_LEFT"},{"Ear (Right)":"EAR_RIGHT"},{"Nose (Bridge)":"NOSE_BRIDGE"},{"Nose (Tip)":"NOSE_TIP"},{"Nose (Base)":"NOSE_BASE"},{"Lip (Top)":"LIP_TOP"},{"Lip (Bottom)":"LIP_BOTTOM"},{"Mouth (Center)":"MOUTH_CENTER"},{Chin:"CHIN"},{"Eyebrow (Left)":"EYEBROW_LEFT"},{"Eyebrow (Right)":"EYEBROW_RIGHT"}],default:"none",description:"Which face feature the landmark should track to"}),ZapparFaceLandmark.attributes.add("Face Tracker",{type:"entity",description:"Face Tracker (Drag from hierarchy)"}),ZapparFaceLandmark.attributes.add("Zappar Camera",{type:"entity",description:"Zappar Camera (Drag from hierarchy)"}),ZapparFaceLandmark.prototype.initialize=function(){const a=Zappar.FaceLandmarkName[this["Landmark Target"]];this.faceLandmark=new Zappar.FaceLandmark(a)},ZapparFaceLandmark.prototype.update=function(){if(!this["Zappar Camera"])throw new Error("Zappar Camera attribute undefined - Please link camera entity to attribute.");if(!this["Face Tracker"])throw new Error("Face Tracker attribute undefined - Please link face tracker entity to attribute.");const{faceTracker:a}=this["Face Tracker"].script.zapparFaceTracker,e=this["Zappar Camera"].script.zapparCamera,{pipeline:r}=e,t=e["Camera Pose"],i="poses"===e["Mirror Mode"];let n=r.cameraPoseDefault();switch(t){case"attitude":n=r.cameraPoseWithAttitude(i);break;case"anchor":{const e=a.anchors.values().next().value;e&&(n=r.cameraPoseWithOrigin(e.poseCameraRelative(i)));break}}a.visible.forEach((a=>{const e=(new pc.Mat4).set(Array.from(a.pose(n,i)));this.faceLandmark.updateFromFaceAnchor(a,i);const r=e.mul((new pc.Mat4).set(Array.from(this.faceLandmark.pose)));this.entity.setEulerAngles(r.getEulerAngles().x,r.getEulerAngles().y,r.getEulerAngles().z),this.entity.setPosition(r.getTranslation())}))};const ZapparFaceMesh=pc.createScript("zapparFaceMesh");ZapparFaceMesh.attributes.add("Face Tracker",{type:"entity",description:"Face Tracker (Drag from hierarchy)"}),ZapparFaceMesh.attributes.add("Zappar Camera",{type:"entity",description:"Zappar Camera (Drag from hierarchy)"}),ZapparFaceMesh.attributes.add("Fill mouth",{type:"boolean",default:!1,description:"Mesh fills mouth"}),ZapparFaceMesh.attributes.add("Fill eye (left)",{type:"boolean",default:!1,description:"Mesh fills eye"}),ZapparFaceMesh.attributes.add("Fill eye (right)",{type:"boolean",default:!1,description:"Mesh fills eye"}),ZapparFaceMesh.attributes.add("Mask",{type:"boolean",default:!1,description:"Occlude depth, do not render colors"}),ZapparFaceMesh.attributes.add("Full Head",{type:"boolean",default:!1,description:"Use full head mesh?"}),ZapparFaceMesh.attributes.add("material",{type:"asset",assetType:"material",description:"The material that the mesh uses"}),ZapparFaceMesh.prototype.initialize=function(){if(!this["Zappar Camera"])throw new Error("Zappar Camera attribute undefined - Please link camera entity to attribute.");if(!this["Face Tracker"])throw new Error("Face Tracker attribute undefined - Please link face tracker entity to attribute.");this.ZfaceMesh=new Zappar.FaceMesh;(this["Full Head"]?this.ZfaceMesh.loadDefaultFullHeadSimplified(this["Fill mouth"],this["Fill eye (left)"],this["Fill eye (right)"]):this.ZfaceMesh.loadDefaultFace(this["Fill mouth"],this["Fill eye (left)"],this["Fill eye (right)"])).then((()=>{const e=new pc.GraphNode,t=new pc.Model;t.graph=e;const a=pc.createMesh(this.app.graphicsDevice,Array.from(this.ZfaceMesh.vertices),{normals:Array.from(this.ZfaceMesh.normals),uvs:Array.from(this.ZfaceMesh.uvs)});let s;if(this.entity.removeComponent("model"),this.entity.addComponent("model"),this.Mask){let e=this.app.assets.find("Occluder");e?(s=e.resource,s.depthTest=!0,s.depthWrite=!0,s.blueWrite=!1,s.redWrite=!1,s.greenWrite=!1,s.alphaWrite=!1):(s=this.material.resource,console.warn('Zappar: Missing "Occluder material'))}else s=this.material.resource;const r=new pc.MeshInstance(a,s,e);t.meshInstances.push(r),this.entity.model&&(this.entity.model.model=t),this.entity.rotateLocal(0,180,0)})),this.faceTracker=this["Face Tracker"].script.zapparFaceTracker.faceTracker,this.Camera=this["Zappar Camera"].script.zapparCamera},ZapparFaceMesh.prototype.update=function(){this.faceTracker.visible.forEach((e=>{if(this.ZfaceMesh.updateFromFaceAnchor(e),this.entity.model&&this.entity.model.meshInstances[0]){const e=this.entity.model.meshInstances[0].mesh;e.setPositions(this.ZfaceMesh.vertices),e.setUvs(0,this.ZfaceMesh.uvs),e.setIndices(this.ZfaceMesh.indices),e.setNormals(this.ZfaceMesh.normals),e.update()}}))};const zapparBrowserUtil=pc.createScript("zapparBrowserUtil");zapparBrowserUtil.attributes.add("Mobile Only",{type:"boolean",default:!1,description:"Redirect users to mobile"}),zapparBrowserUtil.attributes.add("Compatibility Check",{type:"boolean",default:!1,description:"Perform compatability checks"}),zapparBrowserUtil.prototype.initialize=function(){this["Compatibility Check"]&&Zappar.browserIncompatible()&&(Zappar.browserIncompatibleUI(),this.app.autoRender=!1),this["Mobile Only"]&&(MobileOnly.isMobile()||(MobileOnly.showUI(),this.app.autoRender=!1))};var RocketFly=pc.createScript("rocketFly");RocketFly.attributes.add("speed",{type:"number",default:.1}),RocketFly.attributes.add("targetHeight",{type:"number",default:4}),RocketFly.prototype.initialize=function(){this.target=new pc.Vec3(0,this.targetHeight,0),this.lerpedPosition=new pc.Vec3,this.flying=!1;this.app.on("game:rocket_launch",(()=>{this.flying=!0})),this.app.on("game:rocket_reset",(()=>{const t=new pc.Vec3(0,0,0);this.entity.setLocalPosition(t),this.flying=!1}))},RocketFly.prototype.update=function(t){if(!this.flying)return;const e=this.speed*t;this.lerpedPosition.lerp(this.entity.getLocalPosition(),this.target,e),this.entity.setLocalPosition(this.lerpedPosition)};var Drift=pc.createScript("drift");Drift.attributes.add("Resistance",{type:"number",default:100,description:"Resistance"}),Drift.prototype.initialize=function(){this.dx=0},Drift.prototype.update=function(t){this.dx+=.01+t;const i=Math.sin(this.dx)/this.Resistance,e=this.entity.getLocalEulerAngles();this.entity.setLocalEulerAngles(e.x+i,e.y+i,e.z+i)};var Ui=pc.createScript("ui");Ui.attributes.add("Button",{type:"entity",description:"Button which sets placement mode, launches rocket and resets position"}),Ui.attributes.add("ButtonText",{type:"entity",description:"Button Text"}),Ui.prototype.initialize=function(){const t=this.Button,e=this.ButtonText,i={PLACE:0};Object.freeze(i);let n=i.PLACE;const onButtonPress=()=>{switch(n){case i.PLACE:this.app.fire("game:rocket_placed"),n=i.PLACE,e.element.text="TAP TO PLACE";break;case i.RESET:this.app.fire("game:rocket_reset"),n=i.PLACE,e.element.text="TAP TO PLACE"}};t.element.on("mousedown",onButtonPress),t.element.on("touchstart",onButtonPress)},Ui.prototype.update=function(t){};var Particles=pc.createScript("particles");Particles.prototype.initialize=function(){const t=this.entity.particlesystem;this.app.on("game:rocket_launch",(function startParticles(){t.enabled=!0,t.play()})),this.app.on("game:rocket_reset",(function stopParticles(){t.enabled=!1,t.stop()}))};const ZapparProbeSphere=pc.createScript("zapparProbeSphere");ZapparProbeSphere.attributes.add("Zappar Camera",{type:"entity",description:"The Zappar Camera"}),ZapparProbeSphere.prototype.initialize=function(){const a=new pc.BasicMaterial;if(!this["Zappar Camera"])return;const e=this["Zappar Camera"].script.zapparCamera.texture;a.colorMap=e,a.cull=pc.CULLFACE_NONE,this.entity.render&&(this.entity.render.material=a)};var CubemapRenderer=pc.createScript("cubemapRenderer");CubemapRenderer.attributes.add("resolution",{title:"Resolution",description:"Resolution of one side of a cubemap. Use power of 2 resolution if you wish to use Mipmaps.",type:"number",default:512}),CubemapRenderer.attributes.add("mipmaps",{title:"Mipmaps",description:"If set to true, mipmaps will be allocated and autogenerated.",type:"boolean",default:!0}),CubemapRenderer.attributes.add("depth",{title:"Depth",description:"If set to true, depth buffer will be created.",type:"boolean",default:!0}),CubemapRenderer.prototype.initialize=function(){var e=this.entity.camera;if(!e)return void console.error("CubemapRenderer component requires Camera component to be created on the Entity.");e.enabled=!1;var t=Math.min(this.resolution,this.app.graphicsDevice.maxCubeMapSize);this.cubeMap=new pc.Texture(this.app.graphicsDevice,{width:t,height:t,format:pc.PIXELFORMAT_R8_G8_B8_A8,cubemap:!0,mipmaps:this.mipmaps,minFilter:pc.FILTER_LINEAR_MIPMAP_LINEAR,magFilter:pc.FILTER_LINEAR});for(var r=[(new pc.Quat).setFromEulerAngles(0,90,180),(new pc.Quat).setFromEulerAngles(0,-90,180),(new pc.Quat).setFromEulerAngles(90,0,0),(new pc.Quat).setFromEulerAngles(-90,0,0),(new pc.Quat).setFromEulerAngles(0,180,180),(new pc.Quat).setFromEulerAngles(0,0,180)],a=0;a<6;a++){var i=new pc.RenderTarget(this.app.graphicsDevice,this.cubeMap,{depth:this.depth,face:a}),p=new pc.Entity("CubeMapCamera_"+a);p.addComponent("camera",{aspectRatio:1,fov:90,layers:e.layers,priority:e.priority,clearColor:e.clearColor,clearColorBuffer:e.clearColorBuffer,clearDepthBuffer:e.clearDepthBuffer,clearStencilBuffer:e.clearStencilBuffer,farClip:e.farClip,nearClip:e.nearClip,frustumCulling:e.frustumCulling,renderTarget:i}),this.entity.addChild(p),p.setRotation(r[a])}
//! Note, changing the material's properties in the editor at runtime
this.app.assets.findByTag("reflective").forEach((e=>{e.resource.cubeMap=this.cubeMap,e.resource.update()}))},CubemapRenderer.prototype.update=function(){};var Shadow=pc.createScript("shadow");Shadow.attributes.add("shadowStrength",{type:"number",default:.5,min:0,max:1,title:"Shadow Strength",description:"Control the strength of the shadow. 1 is full strength and 0 is disabled. Defaults to 0.5."}),Shadow.prototype.initialize=function(){var t=new pc.StandardMaterial;t.chunks.lightDiffuseLambertPS="float getLightDiffuse() { return 1.0; }",t.chunks.outputAlphaPS="gl_FragColor.a = dAlpha * (1.0 - dDiffuseLight.r);",t.diffuse.set(0,0,0),t.specular.set(0,0,0),t.emissive.set(0,0,0),t.opacity=this.shadowStrength,t.blendType=pc.BLEND_NORMAL,t.useGammaTonemap=!1,t.useFog=!1,t.useSkybox=!1,t.depthWrite=!1,t.update(),Shadow.shadowMaterial=t,this.shadowEntity=new pc.Entity("Shadow"),this.shadowEntity.addComponent("model",{type:"plane",castShadows:!1}),this.shadowEntity.model.material=Shadow.shadowMaterial,this.shadowEntity.setLocalScale(5,5,5),this.entity.addChild(this.shadowEntity)};